
<template>

<div class="chart-box" v-show="chartsAvailable">
	<div class="row">
		<div class="col-sm">
			<TSChart height="120px" name="Traffic Rate" :series="chart1Series" unit="bps"></TSChart>
			<small class="text-muted stats-info">Actual Throughput: <span>{{ actual_throughput }}</span></small>
		</div>
		<div class="col-sm">
			<TSChart height="120px" name="Packet Loss" :series="chart3Series" unit="pps"></TSChart>
			<small class="text-muted stats-info">Packet Loss Since Service Startup: <span>{{ total_loss }}</span></small>
		</div>
		<div class="col-sm">
			<TSChart height="120px" name="I/O Throughput" :series="chart2Series" unit="bps"></TSChart>
			<small class="text-muted stats-info">Service Uptime: <span>{{ service_uptime }}</span></small>
		</div>
	</div>
</div>

<div class="configuration">
<div class="card w-100">
	<div class="card-header">
		<div class="card-title">
			<h3>{{ label }} Instance</h3>
		</div>
		<div class="service-switch">
			<Toggle v-model="n2diskSwitch" onLabel="On" offLabel="Off" @change="onServiceSwitchChange()" :class="{ 'toggle-red': n2diskEnabled && !n2diskActive }" />
		</div>
	</div>

	<div class="card-body">

		<!-- <p class="card-text">Sample text.</p>-->

		<div class="form-group">
			<h5>Interface</h5>
			<Multiselect v-model="selectedInterfaces" :options="interfacesList" mode="single" :preselect-first="true" placeholder="Select the interfaces" :close-on-select="true" ref="interfaceMultiselect" :class="{ 'border border-danger': invalidInterface }" @change="onConfigChange()" @select="onInterfaceSelect()" />
			<small class="form-text text-muted">Network interface used for packet capture.</small>
		</div>

		<div class="form-group">
			<h5>Storage Path</h5>
			<input type="text" class="form-control" :class="{ 'border border-danger': invalidStoragePath }" ref="storagePath" @change="onConfigChange()" />
			<small class="form-text text-muted">Folder where PCAP files are stored.</small>
		</div>

		<div class="form-group">
			<h5>Disk Limit</h5>
			<Slider v-model="diskLimit" :format="formatPercentage" :min="minDiskLimit" ref="diskLimitSlider" @change="onConfigChange()" />
			<small class="form-text text-muted">Limit the disk space utilization as percentage of the storage size. Recommended value for a dedicated storage is 80%.</small>
		</div>

		<div class="form-group">
			<h5>File Size</h5>
			<Slider v-model="fileSize" :format="formatSize" :min="minFileSize" :max="maxFileSize" :step="stepFileSize" ref="fileSizeSlider" @change="onConfigChange()" />
			<small class="form-text text-muted">Maximum size for PCAP files generated by n2disk.</small>
		</div>

		<div class="form-group">
			<a class="btn" data-bs-toggle="collapse" href="#collapseAdvancedSettings" role="button" aria-expanded="false" aria-controls="collapseAdvancedSettings"><h5>Advanced Settings <font-awesome-icon icon="fa-solid fa-angle-down" /></h5></a>
			<div class="form-floating collapse" id="collapseAdvancedSettings">
				<textarea class="form-control input-textarea" placeholder="Advanced settings" id="advancedSettingsTextareaId" ref="advancedSettingsTextarea" @change="onConfigChange()"></textarea>
				<label for="advancedSettingsTextareaId">key = value</label>
			</div>
		</div>

	</div>

	<div class="card-footer">
		<div class="d-grid gap-2 d-md-flex justify-content-md-end">
			<button class="btn btn-danger" @click="onDeleteModal.show();">Delete Instance</button>
			<button class="btn btn-primary" @click="saveConfiguration()" :disabled="!configChanged || !validationOk">Save Configuration</button>
		</div>
	</div>
</div>

<Modal ref="onDeleteModal">
	<template v-slot:title>
		Delete {{ name }} Instance
	</template>
	<template v-slot:body>
		Are you sure you want to delete this {{ serviceName }} instance and its configuration?
	</template>
	<template v-slot:footer>
		<button class="btn btn-primary" @click="deleteConfiguration(); onDeleteModal.close()">Confirm</button>
		<button class="btn btn-secondary" @click="onDeleteModal.close()">Close</button>
	</template>
</Modal>

<Modal ref="onApplyModal">
	<template v-slot:title>
		{{ serviceName }} is running
	</template>
	<template v-slot:body>
		The configuration has been modified while {{ serviceName }} was running, please restart the service to apply the changes.
	</template>
	<template v-slot:footer>
		<button class="btn btn-primary" @click="restartService(serviceName, name); onApplyModal.close()">Restart</button>
		<button class="btn btn-secondary" @click="onApplyModal.close()">Close</button>
	</template>
</Modal>

<Modal ref="createInterfaceModal">
	<template v-slot:title>
		Add Custom Interface
	</template>
	<template v-slot:body>
		<div class="form-group">
			<h5>Interface Name</h5>
			<input type="text" class="form-control" :class="{ 'border border-danger': interfaceModalInvalidInterfaceName }" ref="interfaceModalInterfaceName" @change="onInterfaceModalChange()" />
			<small class="form-text text-muted">Specify the name of the custom interface to be created.</small>
		</div>
	</template>
	<template v-slot:footer>
		<button class="btn btn-primary" @click="createInterface(); createInterfaceModal.close()" :disabled="!interfaceModalValidationOk">Create</button>
		<button class="btn btn-secondary" @click="createInterfaceModal.close()">Close</button>
	</template>
</Modal>

</div>

</template>

<script setup>
import { ref, onMounted, onBeforeMount, computed, watch } from "vue";
import { useToast } from "vue-toastification";
import { stubMode, isEndpoint, isIPPort, getLSBRelease, getNetworkInterfaces, isServiceActive, isServiceEnabled, toggleService, deleteService, restartService, readConfigurationFile, parseConfiguration, writeConfigurationFile, readMetadata, writeMetadata, deleteMetadata, deleteConfigurationFile, getRRDData, isValidPath, createPath, getServicePID, getServiceStats } from "../functions";
import Multiselect from '@vueform/multiselect'
import Slider from '@vueform/slider'
import Toggle from '@vueform/toggle'
import Modal from './Modal.vue'
import TagInput from "./TagInput.vue";
import TSChart from './TSChart.vue'

const toast = useToast();

/* 
 * Component parameters
 * Types: String, Object, Number, Boolean, Array
 * Print with console.logs(props.name);
 */
const props = defineProps({
	name: {
		type: String,
		required: true
	},
	label: {
		type: String,
		required: true
	}
})

const serviceName = "n2disk";

const customInterfaceLabel = "Add Custom Interface..";

/* Service status */
const n2diskActive = ref(false);
const n2diskEnabled = ref(false);
const n2diskSwitch = ref(false)

/* Empty configuration */
const diskLimit = ref(80);
const minDiskLimit = ref(1);
const fileSize = ref(1024);
const minFileSize = ref(64);
const maxFileSize = ref(4096);
const stepFileSize = ref(64);
const selectedInterfaces = ref([]);
const localNetworks = ref([])
let bufferLen = 0;

/* Form data */
const interfaceMultiselect = ref(null);
const diskLimitSlider = ref(null);
const fileSizeSlider = ref(null);
const storagePath = ref(null)
const advancedSettingsTextarea = ref(null);
const configChanged = ref(false)
const onApplyModal = ref(null)
const onDeleteModal = ref(null)

const validationOk = ref(true);
const invalidInterface = ref(false)
const invalidStoragePath = ref(false)

/* Custom Interface Modal Form */
const createInterfaceModal = ref(null)
const interfaceModalInterfaceName = ref(null)

const interfaceModalValidationOk = ref(true)
const interfaceModalInvalidInterfaceName = ref(false)

/* Data */
const interfacesList = ref([]);

/* Charts */
const chartsAvailable = ref(stubMode() ? true : false);
const chart1Series = ref([{ name: 'RXBytes', data: [] }])
const chart2Series = ref([{ name: 'IOBytes', data: [] }])
const chart3Series = ref([{ name: 'Drops', data: [] }])

/* Live Info */
const actual_throughput = ref("");
const total_loss = ref("");
const service_uptime = ref("");

function formatPercentage(value) {
	return Math.round(value) + "%";
}

function formatSize(value) {
	if (value >= 1024)
		return (Math.round((value/1024)*100)/100) + " GB";
	else
		return Math.round(value) + " MB";
}

/* Update service switch state */
async function updateServiceSwitch() {
	/* Service status */
	if (stubMode()) {
		n2diskActive.value = true;
		n2diskEnabled.value = true;
	} else {
		n2diskActive.value = await isServiceActive(serviceName, props.name);
		n2diskEnabled.value = await isServiceEnabled(serviceName, props.name);
	}

	if (n2diskEnabled.value) {
		n2diskSwitch.value = true;
	}

}

function appendAdvancedSettings(name, value) {
	advancedSettingsTextarea.value.value += name;
	if (value)
		advancedSettingsTextarea.value.value += '=' + value;
	advancedSettingsTextarea.value.value += '\n';
}

async function loadConfiguration() {
	let configuration = [];
	let metadata = {};

	/* Read configuration file, if any */
	if (stubMode()) {
		configuration = [ 
			{ name: '-i', value: 'eno1' } 
		];
	} else { 
		metadata = await readMetadata(serviceName, props.name);
		configuration = await readConfigurationFile(serviceName, props.name);
	}

	configuration.forEach(function (option) {
		switch (option.name) {
			case '-i':
			case '--interface':
				if (option.value) {
					const found = interfacesList.value.find(ifname => ifname == option.value);
					if (!found) {
						/* Custom interface? Adding to the list.. */
						interfacesList.value.unshift(option.value);
					}
					selectedInterfaces.value.push(option.value);
				}
				break;
			case '-o':
			case '--dump-directory':
				if (option.value) {
					if (storagePath.value.value) {
						appendAdvancedSettings(option.name, option.value);
					} else {
						storagePath.value.value = option.value;
					}
				}
				break;
			case '-6':
			case '--disk-limit':
				diskLimit.value = option.value.replace('%','');
				break;
			case '-p':
			case '--max-file-len':
				fileSize.value = option.value;
				break;
			case '-A':
			case '--timeline-dir':
				appendAdvancedSettings(option.name, option.value);
				break;
			case '-I':
			case '--index':
				appendAdvancedSettings(option.name, option.value);
				break;
			default:
				appendAdvancedSettings(option.name, option.value);
				break;
		}
	});

	/* Update configChanged with timeout to handle async updates triggering change event */
	setTimeout(() => (configChanged.value = false), 100);
}

function computeConfiguration() {
	let form_configuration = []

	const advanced_configuration = parseConfiguration(advancedSettingsTextarea.value.value);

	if (selectedInterfaces.value && selectedInterfaces.value != '') {
		form_configuration.push({ name: '--interface', value: selectedInterfaces.value });
	}
	
	if (storagePath.value.value) {
		form_configuration.push({ name: '--dump-directory', value: storagePath.value.value });
		const timelineDefined = advanced_configuration.find(element => (element.name == '-A' || element.name == '--timeline-dir'));
		if (!timelineDefined) {
			form_configuration.push({ name: '--timeline-dir', value: storagePath.value.value });
		}
	}

	const indexDefined = advanced_configuration.find(element => (element.name == '-I' || element.name == '--index'));
	if (!indexDefined) {
		form_configuration.push({ name: '--index' });
	}

	form_configuration.push({ name: '--disk-limit',   value: diskLimit.value + "%" });
	form_configuration.push({ name: '--max-file-len', value: fileSize.value });

	const bufferLenDefined = advanced_configuration.find(element => (element.name == '-b' || element.name == '--buffer-len'));
	if (!bufferLenDefined) {
		bufferLen = parseInt(fileSize.value) * 4;
		form_configuration.push({ name: '--buffer-len', value: bufferLen });
	}

	const configuration = form_configuration.concat(advanced_configuration);

	return configuration;
}

function computeMetadata() {
	let metadata = {};
	return metadata;
}

async function deleteConfiguration() {
	deleteService(serviceName, props.name);
	deleteMetadata(serviceName, props.name);
	deleteConfigurationFile(serviceName, props.name);
	location.reload();
}

/* Before mount: initialize configuration */
onBeforeMount(async () => {
	let interface_names = []

	updateServiceSwitch();

	/* Read interfaces */
	if (stubMode()) {
		interface_names = ['eno1', 'eno2'];
	} else {
		let interfaces = await getNetworkInterfaces();
		interface_names = interfaces.map(info => info.name);
	}

	interface_names.push(customInterfaceLabel);

	interfacesList.value = interface_names
});

/* On service switch event: toggle service status */
function onServiceSwitchChange() {
	if (stubMode()) {
		console.log("Switching " + serviceName + " " + n2diskSwitch.value);
	} else {
		toggleService(serviceName, n2diskSwitch.value, props.name);
	}

	/* This is not required as there is a setInterval
	setTimeout(() => {
		updateServiceSwitch();
	}, 2000)
	*/
}

function onConfigChange(e, checkEmpty) {
	/* Use @change="event => onConfigChange(event)" to pass the event */
	/* if (e) { 
	 * 	console.log(e);
	 * 	console.log(e.target.value);
	 * } */

	/* Reset */
	invalidInterface.value = false;
	invalidStoragePath.value = false;

	/* Validate */
	const interfaceName = selectedInterfaces.value;
	if (checkEmpty && !interfaceName) {
		invalidInterface.value = true;
	}

	const path = storagePath.value.value;
	if ((checkEmpty && !path) || (path && !isValidPath(path))) {
		invalidStoragePath.value = true;
	}

	/* Update global validation flag */
	validationOk.value =
		!invalidStoragePath.value &&
		!invalidInterface.value;

	/* Set config changed */
	configChanged.value = true;
}

/* Called on modal form change to validate the custom interface name */
function onInterfaceModalChange(e) {
	/* Reset */
	interfaceModalInvalidInterfaceName.value = false;

	/* Validate */
	const name = interfaceModalInterfaceName.value.value;
	if (name && !isValidInterfaceName(name)) {
		interfaceModalInvalidInterfaceName.value = true;
	}
	
	/* Update global validation flag */
	interfaceModalValidationOk.value = name && !interfaceModalInvalidInterfaceName.value;
}

/* Create a custom interface - called by the modal */
function createInterface() {
	const name = interfaceModalInterfaceName.value.value;
	const found = interfacesList.value.find(ifname => ifname == name);
	if (found) {
		toast.warning(name + " already present");
		return;
	}

	interfacesList.value.unshift(name);
	selectedInterfaces.value = name;

	/* Reset modal */
	interfaceModalInterfaceName.value.value = '';
}

/* Called on interface selected */
async function onInterfaceSelect(e) {
	if (selectedInterfaces.value == customInterfaceLabel) {
		selectedInterfaces.value = '';
		createInterfaceModal.value.show();
		return;
	}

	onConfigChange(e);
}

async function saveConfiguration() {

	onConfigChange({}, true);
	if (validationOk.value == false) {
		return;
	}

	const configuration = computeConfiguration();
	const metadata = computeMetadata();

	let success = false;
	let message = "";

	if (stubMode()) {
		console.log(configuration);
	} else {
		try {
			/* Create n2disk folder */
			const storageDefined = configuration.find(element => (element.name == '-O' || element.name == '--dump-directory'));
			if (storageDefined) {
				await createPath(storageDefined.value /* path */, "n2disk" /* user */)
			}

			/* Write configuration and metadata */
			await writeMetadata(serviceName, metadata, props.name);
			success = await writeConfigurationFile(serviceName, configuration, props.name);
		} catch (err) {
			if (err.message) {
				message = err.message;
			}
		}
	}

	if (success) {
		toast.success("Configuration saved!");
	
		/* Update configChanged with timeout to handle async updates triggering change event */
		setTimeout(() => (configChanged.value = false), 100);

		if (n2diskEnabled.value) {
			onApplyModal.value.show();
		}
	} else {
		toast.warning("Unable to write the configuration. " + message);
	}
}

async function updateCharts() {
	if (stubMode()) {
		let sample_data = [];
		sample_data.push({ x: (Date.now()-10000), y: 10 });
		sample_data.push({ x: (Date.now()), y: 20 });

		chart1Series.value[0].data = sample_data;
		chart2Series.value[0].data = sample_data;
		chart3Series.value[0].data = sample_data;

		chartsAvailable.value = true;

		return;
	}

	let data = await getRRDData(serviceName, props.name, 10 /* last 10 minutes */);

	if (data && 
	    data['receivedBytes'] && 
	    data['receivedBytes'].length > 1 && 
	    data['dumpedBytes'] && 
	    data['dumpedBytes'].length > 1) {
		/*
		 * Available RRDs:
		 * receivedPkts
		 * filteredPkts
		 * receivedBytes
		 * droppedPkts
		 */

		chart1Series.value[0].data = data['receivedBytes'];
		chart2Series.value[0].data = data['dumpedBytes'];
		chart3Series.value[0].data = data['droppedPkts'];

		chartsAvailable.value = true;

		let stats = await getServiceStats(serviceName, props.name);
		actual_throughput.value = stats["Throughput"] ? stats["Throughput"] : "";
		total_loss.value =        stats["Dropped"]    ? stats["Dropped"]    : "";
		service_uptime.value =    stats["Duration"]   ? stats["Duration"]   : "";
	}
}

/* On mount: load configuration from file */
onMounted(async () => {
	await loadConfiguration();

	setInterval(() => {
		updateServiceSwitch();
	}, 2000)

	updateCharts();
	setInterval(() => {
		updateCharts();
	}, 5000)
});

</script>

<style src="@vueform/multiselect/themes/default.css"></style>
<style src="@vueform/toggle/themes/default.css"></style>
<style src="@vueform/slider/themes/default.css"></style>
